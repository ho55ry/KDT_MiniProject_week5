logo
코딩테스트 연습
2023 KAKAO BLIND RECRUITMENT
1,2,3 떨어트리기
도움말
컴파일 옵션
1,2,3 떨어트리기
문제 설명
춘식이는 트리의 1번 노드에 숫자 1, 2, 3 중 하나씩을 계속해서 떨어트려 트리의 리프 노드1에 숫자를 쌓는 게임을 하려고 합니다.
아래 그림은 게임의 예시를 나타냅니다.

railroad.jpg

트리의 모든 간선은 부모 노드가 자식 노드를 가리키는 단방향 간선입니다.
모든 부모 노드는 자식 노드와 연결된 간선 중 하나를 길로 설정합니다.
실선 화살표는 길인 간선입니다.
점선 화살표는 길이 아닌 간선입니다.
모든 부모 노드는 자신의 자식 노드 중 가장 번호가 작은 노드를 가리키는 간선을 초기 길로 설정합니다.
[게임의 규칙]은 아래와 같습니다.

1번 노드(루트 노드)에 숫자 1, 2, 3 중 하나를 떨어트립니다.
숫자는 길인 간선을 따라 리프 노드까지 떨어집니다.
숫자가 리프 노드에 도착하면, 숫자가 지나간 각 노드는 현재 길로 연결된 자식 노드 다음으로 번호가 큰 자식 노드를 가리키는 간선을 새로운 길로 설정하고 기존의 길은 끊습니다.
만약 현재 길로 연결된 노드의 번호가 가장 크면, 번호가 가장 작은 노드를 가리키는 간선을 길로 설정합니다.
노드의 간선이 하나라면 계속 하나의 간선을 길로 설정합니다.
원하는 만큼 계속해서 루트 노드에 숫자를 떨어트릴 수 있습니다.
단, 앞서 떨어트린 숫자가 리프 노드까지 떨어진 후에 새로운 숫자를 떨어트려야 합니다.
[게임의 목표]는 각각의 리프 노드에 쌓인 숫자의 합을 target에서 가리키는 값과 같게 만드는 것입니다.
예를 들어, target이 [0, 0, 0, 3, 0, 0, 5, 1, 2, 3]일 경우 아래 표와 같은 의미를 가집니다.

노드 번호	노드에 쌓인 숫자의 합
1	0
2	0
3	0
4	3
5	0
6	0
7	5
8	1
9	2
10	3
target대로 리프 노드에 쌓인 숫자의 합을 맞추기 위해서는 [2, 1, 2, 2, 1, 3, 3]순으로 숫자를 떨어트리면 됩니다.

아래 두 그림은 순서대로 1, 2번째 숫자 [2, 1]을 떨어트린 뒤의 길 상황을 나타냅니다.
railroad21.jpg

숫자 2는 떨어지면서 1번 노드와 2번 노드를 지나갔습니다.
1번 노드는 3번 노드를 가리키는 간선을 길로 설정합니다.
2번 노드는 5번 노드를 가리키는 간선을 길로 설정합니다.
숫자 1은 떨어지면서 1번 노드, 3번 노드, 6번 노드를 지나갔습니다.
1번 노드는 3번 노드보다 번호가 큰 노드를 가리키는 간선이 없으므로 다시 2번 노드를 가리키는 간선을 길로 설정합니다.
3번 노드는 간선이 하나이므로 계속해서 6번 노드를 가리키는 간선을 길로 설정합니다.
6번 노드는 9번 노드를 가리키는 간선을 길로 설정합니다.
아래 두 그림은 순서대로 3, 4번째 숫자 [2, 2]를 떨어트린 뒤의 길 상황을 나타냅니다.
railroad2122.jpg

아래 세 그림은 순서대로 5, 6, 7번째 숫자 [1, 3, 3]을 떨어트린 뒤의 길 상황을 나타냅니다.
railroad2122133.jpg

각 리프 노드에 쌓인 숫자를 모두 더해 배열로 나타내면 target과 같습니다.

트리의 각 노드들의 연결 관계를 담은 2차원 정수 배열 edges, 각 노드별로 만들어야 하는 숫자의 합을 담은 1차원 정수 배열 target이 매개변수로 주어집니다. 이때, target 대로 리프 노드에 쌓인 숫자의 합을 맞추기 위해 숫자를 떨어트리는 모든 경우 중 가장 적은 숫자를 사용하며 그중 사전 순으로 가장 빠른 경우를 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해주세요. 만약, target대로 숫자의 합을 만들 수 없는 경우 [-1]을 return 해주세요.

제한사항
1 ≤ edges의 길이 ≤ 100
edges[i]는 [부모 노드 번호, 자식 노드 번호] 형태로, 단방향으로 연결된 두 노드를 나타냅니다.
1 ≤ 노드 번호 ≤ edges의 길이 + 1
동일한 간선에 대한 정보가 중복해서 주어지지 않습니다.
항상 하나의 트리 형태로 입력이 주어지며, 잘못된 데이터가 주어지는 경우는 없습니다.
1번 노드는 항상 루트 노드입니다.
target의 길이 = edges의 길이 + 1
target[i]는 i + 1번 노드에 쌓인 숫자의 합으로 만들어야 하는 수를 나타냅니다.
0 ≤ 리프 노드의 target값 ≤ 100
리프 노드를 제외한 노드의 target값 = 0
target의 원소의 합은 1 이상입니다.
입출력 예
edges	target	result
[[2, 4], [1, 2], [6, 8], [1, 3], [5, 7], [2, 5], [3, 6], [6, 10], [6, 9]]	[0, 0, 0, 3, 0, 0, 5, 1, 2, 3]	[1, 1, 2, 2, 2, 3, 3]
[[1, 2], [1, 3]]	[0, 7, 3]	[1, 1, 3, 2, 3]
[[1, 3], [1, 2]]	[0, 7, 1]	[-1]
입출력 예 설명
입출력 예 #1

문제 예시와 같습니다. 위의 설명처럼 [2, 1, 2, 2, 1, 3, 3]순으로 숫자를 떨어트리면 target과 같게 만들 수 있지만, 가장 적은 숫자를 사용하며 그중 사전 순으로 가장 빠른 경우는 [1, 1, 2, 2, 2, 3, 3]입니다.

입출력 예 #2

[3, 2, 1, 1, 3]순으로 숫자를 떨어트리거나 [1, 1, 1, 1, 2, 1, 3]순으로 숫자를 떨어트려도 target과 같게 만들 수 있지만, 가장 적은 숫자를 사용하며 그중 사전 순으로 가장 빠른 경우는 [1, 1, 3, 2, 3]입니다.

railroad ex2.jpg

입출력 예 #3

예제 3번의 트리는 주어지는 edges의 순서만 다를 뿐, 예제 2번과 같은 트리입니다. 2번 노드에 쌓인 숫자의 합을 7로 만들면서 3번 노드에 쌓인 숫자의 합을 1로 만들도록 숫자를 떨어트리는 방법은 없습니다.
따라서 [-1]을 return 해야 합니다.

리프 노드는 자식 노드가 없는 노드를 뜻합니다. ↩

solution.py
1
def solution(edges, target):
2
    answer = []
3
    return answer
실행 결과
실행 결과가 여기에 표시됩니다.

logo
코딩테스트 연습
2022 KAKAO TECH INTERNSHIP
행렬과 연산
도움말
컴파일 옵션
행렬과 연산
문제 설명
[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]

당신은 행렬에 적용할 수 있는 두 가지 연산을 만들었습니다.

ShiftRow
모든 행이 아래쪽으로 한 칸씩 밀려납니다. 즉, 모든 행에 대해서 i번째 행은 i+1번째 행이 됩니다. (마지막 행은 1번째 행이 됩니다.)
ShiftRow의 예 Untitled Diagram.drawio (52).png
왼쪽 행렬이 초기 상태이고 오른쪽 행렬이 ShiftRow를 한 번 시행한 뒤의 행렬입니다.
1번째 행에 있던 [1,2,3]이 2번째 행으로, 2번째 행에 있던 [4,5,6]이 3번째 행으로, 3번째 행에 있던 [7,8,9]가 1번째 행이 된 것을 확인할 수 있습니다.
Rotate
행렬의 바깥쪽에 있는 원소들을 시계 방향으로 한 칸 회전시킵니다.
행렬의 바깥쪽에 있는 원소들은 첫 행, 첫 열, 끝 행, 끝 열에 포함되는 원소들입니다.
한 칸 회전시킨다는 것은 이 원소들이 시계 방향으로 한 칸씩 밀려난다는 것을 의미합니다. 즉, 다음 4개의 연산이 동시에 시행됩니다.
첫 행에서 끝 열에 있는 원소를 제외한 첫 행의 모든 원소는 오른쪽으로 한 칸 이동합니다.
끝 열에서 끝 행에 있는 원소를 제외한 끝 열의 모든 원소는 아래쪽으로 한 칸 이동합니다.
끝 행에서 첫 열에 있는 원소를 제외한 끝 행의 모든 원소는 왼쪽으로 한 칸 이동합니다.
첫 열에서 첫 행에 있는 원소를 제외한 첫 열의 모든 원소는 위쪽으로 한 칸 이동합니다.
Rotate의 예 Untitled Diagram.drawio (51).png
왼쪽 행렬이 초기 상태이고 오른쪽 행렬이 Rotate를 한 번 시행한 뒤의 행렬입니다.
바깥쪽에 있는 값들이 시계 방향으로 한 칸씩 이동한 것을 확인할 수 있습니다.
당신은 행렬에 연산을 여러 번 시행하려고 합니다.
행렬의 초기 상태를 담고 있는 2차원 정수 배열 rc, 시행할 연산을 순서대로 담고 있는 문자열 배열 operations가 매개변수로 주어졌을 때, 연산을 차례대로 시행한 후의 행렬 상태를 return 하도록 solution 함수를 완성해주세요.

제한사항
2 ≤ rc의 행 길이(=행렬의 가로 길이) ≤ 50,000
rc의 모든 행의 길이는 동일합니다.
2 ≤ rc의 열 길이(=행렬의 세로 길이) ≤ 50,000
rc의 모든 열의 길이는 동일합니다.
4 ≤ rc의 행 길이 x rc의 열 길이 ≤ 100,000
rc[i][j] 는 i+1번째 행 j+1번째 열에 있는 원소를 나타냅니다.
1 ≤ rc[i][j] ≤ 1,000,000
1 ≤ operations의 길이 ≤ 100,000
operations의 원소는 "ShiftRow" 혹은 "Rotate"입니다.
정확성 테스트 케이스 제한 사항

2 ≤ rc의 행 길이(=행렬의 가로 길이) ≤ 1,000
rc의 모든 행의 길이는 동일합니다.
2 ≤ rc의 열 길이(=행렬의 세로 길이) ≤ 1,000
rc의 모든 열의 길이는 동일합니다.
4 ≤ rc의 행 길이 x rc의 열 길이 ≤ 10,000
1 ≤ operations의 길이 ≤ 100
효율성 테스트 케이스 제한 사항

주어진 조건 외 추가 제한사항 없습니다.
입출력 예
rc	operations	result
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]	["Rotate", "ShiftRow"]	[[8, 9, 6], [4, 1, 2], [7, 5, 3]]
[[8, 6, 3], [3, 3, 7], [8, 4, 9]]	["Rotate", "ShiftRow", "ShiftRow"]	[[8, 3, 3], [4, 9, 7], [3, 8, 6]]
[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]	["ShiftRow", "Rotate", "ShiftRow", "Rotate"]	[[1, 6, 7 ,8], [5, 9, 10, 4], [2, 3, 12, 11]]
입출력 예 설명
입출력 예#1

Untitled Diagram.drawio (50).png

위 그림은 ”Rotate”와 ”ShiftRow”를 차례대로 실행한 결과입니다.

따라서 [[8, 9, 6], [4, 1, 2], [7, 5, 3]]을 return 해야 합니다.

입출력 예#2

Untitled Diagram.drawio (49).png

위 그림은 ”Rotate”, ”ShiftRow”, "ShiftRow"를 차례대로 실행한 결과입니다.

따라서 [[8, 3, 3], [4, 9, 7], [3, 8, 6]]을 return 해야 합니다.

입출력 예#3

Untitled Diagram.drawio (54).png

위 그림은 ”ShiftRow”, ”Rotate”, ”ShiftRow”, ”Rotate”를 차례대로 실행한 결과입니다.

따라서 [[1, 6, 7 ,8], [5, 9, 10, 4], [2, 3, 12, 11]]을 return 해야 합니다.

제한시간 안내

정확성 테스트 : 10초
효율성 테스트 : 언어별로 작성된 정답 코드의 실행 시간의 적정 배수
solution.py
1
def solution(rc, operations):
2
    answer = [[]]
3
    return answer
실행 결과
실행 결과가 여기에 표시됩니다.

logo
코딩테스트 연습
2017 팁스타운
단어 퍼즐
도움말
컴파일 옵션
단어 퍼즐
문제 설명
단어 퍼즐은 주어진 단어 조각들을 이용해서 주어진 문장을 완성하는 퍼즐입니다. 이때, 주어진 각 단어 조각들은 각각 무한개씩 있다고 가정합니다. 예를 들어 주어진 단어 조각이 [“ba”, “na”, “n”, “a”]인 경우 "ba", "na", "n", "a" 단어 조각이 각각 무한개씩 있습니다. 이때, 만들어야 하는 문장이 “banana”라면 “ba”, “na”, “n”, “a”의 4개를 사용하여 문장을 완성할 수 있지만, “ba”, “na”, “na”의 3개만을 사용해도 “banana”를 완성할 수 있습니다. 사용 가능한 단어 조각들을 담고 있는 배열 strs와 완성해야 하는 문자열 t가 매개변수로 주어질 때, 주어진 문장을 완성하기 위해 사용해야 하는 단어조각 개수의 최솟값을 return 하도록 solution 함수를 완성해 주세요. 만약 주어진 문장을 완성하는 것이 불가능하면 -1을 return 하세요.

제한사항
strs는 사용 가능한 단어 조각들이 들어있는 배열로, 길이는 1 이상 100 이하입니다.
strs의 각 원소는 사용 가능한 단어조각들이 중복 없이 들어있습니다.
사용 가능한 단어 조각들은 문자열 형태이며, 모든 단어 조각의 길이는 1 이상 5 이하입니다.
t는 완성해야 하는 문자열이며 길이는 1 이상 20,000 이하입니다.
모든 문자열은 알파벳 소문자로만 이루어져 있습니다.
입출력 예
strs	t	result
["ba","na","n","a"]	"banana"	3
["app","ap","p","l","e","ple","pp"]	"apple"	2
["ba","an","nan","ban","n"]	"banana"	-1
입출력 예 설명
입출력 예 #1
문제의 예시와 같습니다.

입출력 예 #2
"ap" 1개, "ple" 1개의 총 2개로 "apple"을 만들 수 있으므로 필요한 단어 개수의 최솟값은 2를 return 합니다.

입출력 예 #3
주어진 단어로는 "banana"를 만들 수 없으므로 -1을 return 합니다.

solution.py
1
def solution(strs, t):
2
    answer = 0
3
​
4
    # [실행] 버튼을 누르면 출력 값을 볼 수 있습니다.
5
    print('Hello Python')
6
​
7
    return answer
실행 결과
실행 결과가 여기에 표시됩니다.

logo
코딩테스트 연습
Summer/Winter Coding(~2018)
지형 편집
지형 편집
문제 설명
XX 게임에서는 지형 편집 기능을 이용하여 플레이어가 직접 게임 속 지형을 수정할 수 있습니다. 이 게임에서는 1 x 1 x 1 크기의 정육면체 블록을 쌓아 게임 속 지형을 표현합니다. 이때, 블록이 공중에 떠 있거나, 블록 하나가 여러 개의 칸에 걸쳐 놓일 수는 없습니다. 따라서 지형을 편집하기 위해서는 각 칸의 제일 위에 블록 1개를 새로 추가하거나, 제일 위에 있는 블록 한 개를 삭제하는 방식으로 지형을 수정해야 합니다. 이때, 블록 한 개를 새로 추가하거나 삭제하기 위해서는 게임머니를 사용해야 하므로 몇 개의 블록을 추가하고 삭제할지 신중한 선택이 필요합니다.

이 게임을 즐기던 한 플레이어는 N x N 크기의 지역에 자신만의 별장을 만들고 싶어졌습니다. 이를 위해서는 울퉁불퉁한 지형의 모든 칸의 높이가 같아지도록 만들어야 합니다. 이때, 블록 한 개를 추가하려면 P의 비용이, 제거하려면 Q의 비용이 들게 됩니다.
다음은 블록 한 개를 추가할 때 5의 비용이, 제거할 때 3의 비용이 드는 경우, 3 x 3 넓이의 모든 칸의 블록 높이가 같아지도록 만드는 예시입니다.

예시1_ciodtv.png

위 그림과 같이 지형 블록이 놓여 있는 경우 모든 칸의 높이가 3으로 같아지도록 한다면 다음과 같은 모양이 됩니다.

예시3_irfpxy.png

이를 위해서는 3보다 높은 칸의 블록 2개를 제거하고, 3보다 낮은 칸에 총 8개의 블록을 추가해야 하며, 2 x 3 + 8 x 5 = 46의 비용이 들게 됩니다.

그러나 아래 그림과 같이 모든 칸의 높이가 2로 같아지도록 할 때는 6개의 블록을 제거하고, 3개의 블록을 추가하면 6 x 3 + 3 x 5 = 33의 비용이 들게 되며, 이때가 최소비용이 됩니다.

예시2_xv5wiz.png

현재 지형의 상태를 나타내는 배열 land와 블록 한 개를 추가하는 데 필요한 비용 P, 블록 한 개를 제거하는 데 필요한 비용 Q가 매개변수로 주어질 때, 모든 칸에 쌓여있는 블록의 높이가 같아지도록 하는 데 필요한 비용의 최솟값을 return 하도록 solution 함수를 완성해 주세요.

제한사항
land는 N x N 크기의 2차원 배열이며, N의 범위는 1 ≤ N ≤ 300입니다.
land의 각 원소는 각 칸에 놓여 있는 블록의 수를 나타내며, 0 이상 10억 이하의 정수입니다.
각 칸에 블록 하나를 추가하는 데는 P, 제거하는 데는 Q의 비용이 들며, P, Q의 범위는 1 ≤ P, Q ≤ 100인 자연수입니다.
입출력 예
land	P	Q	result
[[1, 2], [2, 3]]	3	2	5
[[4, 4, 3], [3, 2, 2], [ 2, 1, 0 ]]	5	3	33
입출력 예 설명
입출력 예 #1

모든 땅의 높이를 1로 맞추는 데는 블록 4개를 제거해야 하므로 8의 비용이 듭니다.
모든 땅의 높이를 2로 맞추는 데는 블록 1개를 추가하고 블록 1개를 제거해야 하므로 5의 비용이 듭니다.
모든 땅의 높이를 3으로 맞추는 데는 블록 4개를 추가해야 하므로 12의 비용이 듭니다.
따라서 최소 비용은 5이므로 5를 return 합니다.

입출력 예 #2
문제의 예시와 같으며 최소 비용은 33입니다.

solution.py
1
def solution(land, P, Q):
2
    answer = -1
3
    return answer
실행 결과
실행 결과가 여기에 표시됩니다.
logo
코딩테스트 연습
2018 KAKAO BLIND RECRUITMENT
[3차] 자동완성
[3차] 자동완성
문제 설명
자동완성
포털 다음에서 검색어 자동완성 기능을 넣고 싶은 라이언은 한 번 입력된 문자열을 학습해서 다음 입력 때 활용하고 싶어 졌다. 예를 들어, go 가 한 번 입력되었다면, 다음 사용자는 g 만 입력해도 go를 추천해주므로 o를 입력할 필요가 없어진다! 단, 학습에 사용된 단어들 중 앞부분이 같은 경우에는 어쩔 수 없이 다른 문자가 나올 때까지 입력을 해야 한다.
효과가 얼마나 좋을지 알고 싶은 라이언은 학습된 단어들을 찾을 때 몇 글자를 입력해야 하는지 궁금해졌다.

예를 들어, 학습된 단어들이 아래와 같을 때

go
gone
guild
go를 찾을 때 go를 모두 입력해야 한다.
gone을 찾을 때 gon 까지 입력해야 한다. (gon이 입력되기 전까지는 go 인지 gone인지 확신할 수 없다.)
guild를 찾을 때는 gu 까지만 입력하면 guild가 완성된다.
이 경우 총 입력해야 할 문자의 수는 7이다.

라이언을 도와 위와 같이 문자열이 입력으로 주어지면 학습을 시킨 후, 학습된 단어들을 순서대로 찾을 때 몇 개의 문자를 입력하면 되는지 계산하는 프로그램을 만들어보자.

입력 형식
학습과 검색에 사용될 중복 없는 단어 N개가 주어진다.
모든 단어는 알파벳 소문자로 구성되며 단어의 수 N과 단어들의 길이의 총합 L의 범위는 다음과 같다.

2 <= N <= 100,000
2 <= L <= 1,000,000
출력 형식
단어를 찾을 때 입력해야 할 총 문자수를 리턴한다.

입출력 예제
words	result
["go","gone","guild"]	7
["abc","def","ghi","jklm"]	4
["word","war","warrior","world"]	15
입출력 설명
첫 번째 예제는 본문 설명과 같다.
두 번째 예제에서는 모든 단어들이 공통된 부분이 없으므로, 가장 앞글자만 입력하면 된다.
세 번째 예제는 총 15 자를 입력해야 하고 설명은 아래와 같다.
word는 word모두 입력해야 한다.
war는 war 까지 모두 입력해야 한다.
warrior는 warr 까지만 입력하면 된다.
world는 worl까지 입력해야 한다. (word와 구분되어야 함을 명심하자)
해설 보러가기

solution.py
1
def solution(words):
2
    answer = 0
3
    return answer
실행 결과
실행 결과가 여기에 표시됩니다.
logo
코딩테스트 연습
2019 KAKAO BLIND RECRUITMENT
무지의 먹방 라이브
무지의 먹방 라이브
문제 설명
무지의 먹방 라이브
* 효율성 테스트에 부분 점수가 있는 문제입니다.

평소 식욕이 왕성한 무지는 자신의 재능을 뽐내고 싶어 졌고 고민 끝에 카카오 TV 라이브로 방송을 하기로 마음먹었다.

muji_live.png

그냥 먹방을 하면 다른 방송과 차별성이 없기 때문에 무지는 아래와 같이 독특한 방식을 생각해냈다.

회전판에 먹어야 할 N 개의 음식이 있다.
각 음식에는 1부터 N 까지 번호가 붙어있으며, 각 음식을 섭취하는데 일정 시간이 소요된다.
무지는 다음과 같은 방법으로 음식을 섭취한다.

무지는 1번 음식부터 먹기 시작하며, 회전판은 번호가 증가하는 순서대로 음식을 무지 앞으로 가져다 놓는다.
마지막 번호의 음식을 섭취한 후에는 회전판에 의해 다시 1번 음식이 무지 앞으로 온다.
무지는 음식 하나를 1초 동안 섭취한 후 남은 음식은 그대로 두고, 다음 음식을 섭취한다.
다음 음식이란, 아직 남은 음식 중 다음으로 섭취해야 할 가장 가까운 번호의 음식을 말한다.
회전판이 다음 음식을 무지 앞으로 가져오는데 걸리는 시간은 없다고 가정한다.
무지가 먹방을 시작한 지 K 초 후에 네트워크 장애로 인해 방송이 잠시 중단되었다.
무지는 네트워크 정상화 후 다시 방송을 이어갈 때, 몇 번 음식부터 섭취해야 하는지를 알고자 한다.
각 음식을 모두 먹는데 필요한 시간이 담겨있는 배열 food_times, 네트워크 장애가 발생한 시간 K 초가 매개변수로 주어질 때 몇 번 음식부터 다시 섭취하면 되는지 return 하도록 solution 함수를 완성하라.

제한사항
food_times 는 각 음식을 모두 먹는데 필요한 시간이 음식의 번호 순서대로 들어있는 배열이다.
k 는 방송이 중단된 시간을 나타낸다.
만약 더 섭취해야 할 음식이 없다면 -1을 반환하면 된다.
정확성 테스트 제한 사항
food_times 의 길이는 1 이상 2,000 이하이다.
food_times 의 원소는 1 이상 1,000 이하의 자연수이다.
k는 1 이상 2,000,000 이하의 자연수이다.
효율성 테스트 제한 사항
food_times 의 길이는 1 이상 200,000 이하이다.
food_times 의 원소는 1 이상 100,000,000 이하의 자연수이다.
k는 1 이상 2 x 10^13 이하의 자연수이다.
입출력 예
food_times	k	result
[3, 1, 2]	5	1
입출력 예 설명
입출력 예 #1

0~1초 동안에 1번 음식을 섭취한다. 남은 시간은 [2,1,2] 이다.
1~2초 동안 2번 음식을 섭취한다. 남은 시간은 [2,0,2] 이다.
2~3초 동안 3번 음식을 섭취한다. 남은 시간은 [2,0,1] 이다.
3~4초 동안 1번 음식을 섭취한다. 남은 시간은 [1,0,1] 이다.
4~5초 동안 (2번 음식은 다 먹었으므로) 3번 음식을 섭취한다. 남은 시간은 [1,0,0] 이다.
5초에서 네트워크 장애가 발생했다. 1번 음식을 섭취해야 할 때 중단되었으므로, 장애 복구 후에 1번 음식부터 다시 먹기 시작하면 된다.
solution.py
1
def solution(food_times, k):
2
    answer = 0
3
    return answer
실행 결과
실행 결과가 여기에 표시됩니다.
logo
코딩테스트 연습
2019 KAKAO BLIND RECRUITMENT
블록 게임
블록 게임
문제 설명
블록게임
프렌즈 블록이라는 신규 게임이 출시되었고, 어마어마한 상금이 걸린 이벤트 대회가 개최 되었다.

이 대회는 사람을 대신해서 플레이할 프로그램으로 참가해도 된다는 규정이 있어서, 게임 실력이 형편없는 프로도는 프로그램을 만들어서 참가하기로 결심하고 개발을 시작하였다.

프로도가 우승할 수 있도록 도와서 빠르고 정확한 프로그램을 작성해 보자.

게임규칙
아래 그림과 같이 1×1 크기의 블록을 이어 붙여 만든 3 종류의 블록을 회전해서 총 12가지 모양의 블록을 만들 수 있다.

blocks_1.png

1 x 1 크기의 정사각형으로 이루어진 N x N 크기의 보드 위에 이 블록들이 배치된 채로 게임이 시작된다. (보드 위에 놓인 블록은 회전할 수 없다). 모든 블록은 블록을 구성하는 사각형들이 정확히 보드 위의 사각형에 맞도록 놓여있으며, 선 위에 걸치거나 보드를 벗어나게 놓여있는 경우는 없다.

플레이어는 위쪽에서 1 x 1 크기의 검은 블록을 떨어뜨려 쌓을 수 있다. 검은 블록은 항상 맵의 한 칸에 꽉 차게 떨어뜨려야 하며, 줄에 걸치면 안된다.
이때, 검은 블록과 기존에 놓인 블록을 합해 속이 꽉 채워진 직사각형을 만들 수 있다면 그 블록을 없앨 수 있다.

예를 들어 검은 블록을 떨어뜨려 아래와 같이 만들 경우 주황색 블록을 없앨 수 있다.

blocks_3.png

빨간 블록을 가로막던 주황색 블록이 없어졌으므로 다음과 같이 빨간 블록도 없앨 수 있다.

blocks_4.png

그러나 다른 블록들은 검은 블록을 떨어뜨려 직사각형으로 만들 수 없기 때문에 없앨 수 없다.

따라서 위 예시에서 없앨 수 있는 블록은 최대 2개이다.

보드 위에 놓인 블록의 상태가 담긴 2차원 배열 board가 주어질 때, 검은 블록을 떨어뜨려 없앨 수 있는 블록 개수의 최댓값을 구하라.

제한사항
board는 블록의 상태가 들어있는 N x N 크기 2차원 배열이다.
N은 4 이상 50 이하다.
board의 각 행의 원소는 0 이상 200 이하의 자연수이다.
0 은 빈 칸을 나타낸다.
board에 놓여있는 각 블록은 숫자를 이용해 표현한다.
잘못된 블록 모양이 주어지는 경우는 없다.
모양에 관계 없이 서로 다른 블록은 서로 다른 숫자로 표현된다.
예를 들어 문제에 주어진 예시의 경우 다음과 같이 주어진다.
blocks_6.png

입출력 예
board	result
[[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,4,0,0,0],[0,0,0,0,0,4,4,0,0,0],[0,0,0,0,3,0,4,0,0,0],[0,0,0,2,3,0,0,0,5,5],[1,2,2,2,3,3,0,0,0,5],[1,1,1,0,0,0,0,0,0,5]]	2
입출력 예 설명
입출력 예 #1
문제에 주어진 예시와 같음

solution.py
1
def solution(board):
2
    answer = 0
3
    return answer
실행 결과
실행 결과가 여기에 표시됩니다.
logo
코딩테스트 연습
Summer/Winter Coding(~2018)
쿠키 구입
쿠키 구입
문제 설명
과자를 바구니 단위로 파는 가게가 있습니다. 이 가게는 1번부터 N번까지 차례로 번호가 붙은 바구니 N개가 일렬로 나열해 놨습니다.

철수는 두 아들에게 줄 과자를 사려합니다. 첫째 아들에게는 l번 바구니부터 m번 바구니까지, 둘째 아들에게는 m+1번 바구니부터 r번 바구니까지를 주려합니다. 단, 두 아들이 받을 과자 수는 같아야 합니다(1 <= l <= m, m+1 <= r <= N). 즉, A[i] 를 i번 바구니에 들어있는 과자 수라고 했을 때, A[l]+..+A[m] = A[m+1]+..+A[r] 를 만족해야 합니다.

각 바구니 안에 들은 과자 수가 차례로 들은 배열 cookie가 주어질 때, 조건에 맞게 과자를 살 경우 한 명의 아들에게 줄 수 있는 가장 많은 과자 수를 return 하는 solution 함수를 완성해주세요. (단, 조건에 맞게 과자를 구매할 수 없다면 0을 return 합니다)

제한사항
cookie의 길이는 1 이상 2,000 이하입니다.
cookie의 각각의 원소는 1 이상 500 이하인 자연수입니다.
입출력 예
cookie	result
[1,1,2,3]	3
[1,2,4,5]	0
입출력 예 설명
입출력 예 #1

첫째 아들에게 2, 3번 바구니를, 둘째 아들에게 4번 바구니를 사주면 두 아들은 각각 과자 3개를 받습니다.

입출력 예 #2

주어진 조건에 맞게 과자를 살 방법이 없습니다.

solution.py
1
def solution(cookie):
2
    answer = -1
3
    return answer
실행 결과
실행 결과가 여기에 표시됩니다.
logo
코딩테스트 연습
2020 KAKAO BLIND RECRUITMENT
가사 검색
가사 검색
문제 설명
[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]

친구들로부터 천재 프로그래머로 불리는 "프로도"는 음악을 하는 친구로부터 자신이 좋아하는 노래 가사에 사용된 단어들 중에 특정 키워드가 몇 개 포함되어 있는지 궁금하니 프로그램으로 개발해 달라는 제안을 받았습니다.
그 제안 사항 중, 키워드는 와일드카드 문자중 하나인 '?'가 포함된 패턴 형태의 문자열을 뜻합니다. 와일드카드 문자인 '?'는 글자 하나를 의미하며, 어떤 문자에도 매치된다고 가정합니다. 예를 들어 "fro??"는 "frodo", "front", "frost" 등에 매치되지만 "frame", "frozen"에는 매치되지 않습니다.

가사에 사용된 모든 단어들이 담긴 배열 words와 찾고자 하는 키워드가 담긴 배열 queries가 주어질 때, 각 키워드 별로 매치된 단어가 몇 개인지 순서대로 배열에 담아 반환하도록 solution 함수를 완성해 주세요.

가사 단어 제한사항
words의 길이(가사 단어의 개수)는 2 이상 100,000 이하입니다.
각 가사 단어의 길이는 1 이상 10,000 이하로 빈 문자열인 경우는 없습니다.
전체 가사 단어 길이의 합은 2 이상 1,000,000 이하입니다.
가사에 동일 단어가 여러 번 나올 경우 중복을 제거하고 words에는 하나로만 제공됩니다.
각 가사 단어는 오직 알파벳 소문자로만 구성되어 있으며, 특수문자나 숫자는 포함하지 않는 것으로 가정합니다.
검색 키워드 제한사항
queries의 길이(검색 키워드 개수)는 2 이상 100,000 이하입니다.
각 검색 키워드의 길이는 1 이상 10,000 이하로 빈 문자열인 경우는 없습니다.
전체 검색 키워드 길이의 합은 2 이상 1,000,000 이하입니다.
검색 키워드는 중복될 수도 있습니다.
각 검색 키워드는 오직 알파벳 소문자와 와일드카드 문자인 '?' 로만 구성되어 있으며, 특수문자나 숫자는 포함하지 않는 것으로 가정합니다.
검색 키워드는 와일드카드 문자인 '?'가 하나 이상 포함돼 있으며, '?'는 각 검색 키워드의 접두사 아니면 접미사 중 하나로만 주어집니다.
예를 들어 "??odo", "fro??", "?????"는 가능한 키워드입니다.
반면에 "frodo"('?'가 없음), "fr?do"('?'가 중간에 있음), "?ro??"('?'가 양쪽에 있음)는 불가능한 키워드입니다.
입출력 예
words	queries	result
["frodo", "front", "frost", "frozen", "frame", "kakao"]	["fro??", "????o", "fr???", "fro???", "pro?"]	[3, 2, 4, 1, 0]
입출력 예에 대한 설명
"fro??"는 "frodo", "front", "frost"에 매치되므로 3입니다.
"????o"는 "frodo", "kakao"에 매치되므로 2입니다.
"fr???"는 "frodo", "front", "frost", "frame"에 매치되므로 4입니다.
"fro???"는 "frozen"에 매치되므로 1입니다.
"pro?"는 매치되는 가사 단어가 없으므로 0 입니다.
solution.py
1
def solution(words, queries):
2
    answer = []
3
    return answer
실행 결과
실행 결과가 여기에 표시됩니다.
logo
코딩테스트 연습
Summer/Winter Coding(2019)
지형 이동
지형 이동
문제 설명
N x N 크기인 정사각 격자 형태의 지형이 있습니다. 각 격자 칸은 1 x 1 크기이며, 숫자가 하나씩 적혀있습니다. 격자 칸에 적힌 숫자는 그 칸의 높이를 나타냅니다.

이 지형의 아무 칸에서나 출발해 모든 칸을 방문하는 탐험을 떠나려 합니다. 칸을 이동할 때는 상, 하, 좌, 우로 한 칸씩 이동할 수 있는데, 현재 칸과 이동하려는 칸의 높이 차가 height 이하여야 합니다. 높이 차가 height 보다 많이 나는 경우에는 사다리를 설치해서 이동할 수 있습니다. 이때, 사다리를 설치하는데 두 격자 칸의 높이차만큼 비용이 듭니다. 따라서, 최대한 적은 비용이 들도록 사다리를 설치해서 모든 칸으로 이동 가능하도록 해야 합니다. 설치할 수 있는 사다리 개수에 제한은 없으며, 설치한 사다리는 철거하지 않습니다.

각 격자칸의 높이가 담긴 2차원 배열 land와 이동 가능한 최대 높이차 height가 매개변수로 주어질 때, 모든 칸을 방문하기 위해 필요한 사다리 설치 비용의 최솟값을 return 하도록 solution 함수를 완성해주세요.

제한사항
land는 N x N크기인 2차원 배열입니다.
land의 최소 크기는 4 x 4, 최대 크기는 300 x 300입니다.
land의 원소는 각 격자 칸의 높이를 나타냅니다.
격자 칸의 높이는 1 이상 10,000 이하인 자연수입니다.
height는 1 이상 10,000 이하인 자연수입니다.
입출력 예
land	height	result
[[1, 4, 8, 10], [5, 5, 5, 5], [10, 10, 10, 10], [10, 10, 10, 20]]	3	15
[[10, 11, 10, 11], [2, 21, 20, 10], [1, 20, 21, 11], [2, 1, 2, 1]]	1	18
입출력 예 설명
입출력 예 #1

각 칸의 높이는 다음과 같으며, 높이차가 3 이하인 경우 사다리 없이 이동이 가능합니다.

land_ladder_5.png

위 그림에서 사다리를 이용하지 않고 이동 가능한 범위는 같은 색으로 칠해져 있습니다. 예를 들어 (1행 2열) 높이 4인 칸에서 (1행 3열) 높이 8인 칸으로 직접 이동할 수는 없지만, 높이가 5인 칸을 이용하면 사다리를 사용하지 않고 이동할 수 있습니다.

따라서 다음과 같이 사다리 두 개만 설치하면 모든 칸을 방문할 수 있고 최소 비용은 15가 됩니다.

높이 5인 칸 → 높이 10인 칸 : 비용 5
높이 10인 칸 → 높이 20인 칸 : 비용 10
입출력 예 #2

각 칸의 높이는 다음과 같으며, 높이차가 1 이하인 경우 사다리 없이 이동이 가능합니다.

land_ladder3.png

위 그림과 같이 (2행 1열) → (1행 1열), (1행 2열) → (2행 2열) 두 곳에 사다리를 설치하면 설치비용이 18로 최소가 됩니다.

solution.py
1
def solution(land, height):
2
    answer = 0
3
    return answer
실행 결과
실행 결과가 여기에 표시됩니다.
logo
코딩테스트 연습
2019 카카오 개발자 겨울 인턴십
호텔 방 배정
호텔 방 배정
문제 설명
[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]

"스노우타운"에서 호텔을 운영하고 있는 "스카피"는 호텔에 투숙하려는 고객들에게 방을 배정하려 합니다. 호텔에는 방이 총 k개 있으며, 각각의 방은 1번부터 k번까지 번호로 구분하고 있습니다. 처음에는 모든 방이 비어 있으며 "스카피"는 다음과 같은 규칙에 따라 고객에게 방을 배정하려고 합니다.

한 번에 한 명씩 신청한 순서대로 방을 배정합니다.
고객은 투숙하기 원하는 방 번호를 제출합니다.
고객이 원하는 방이 비어 있다면 즉시 배정합니다.
고객이 원하는 방이 이미 배정되어 있으면 원하는 방보다 번호가 크면서 비어있는 방 중 가장 번호가 작은 방을 배정합니다.
예를 들어, 방이 총 10개이고, 고객들이 원하는 방 번호가 순서대로 [1, 3, 4, 1, 3, 1] 일 경우 다음과 같이 방을 배정받게 됩니다.

원하는 방 번호	배정된 방 번호
1	1
3	3
4	4
1	2
3	5
1	6
전체 방 개수 k와 고객들이 원하는 방 번호가 순서대로 들어있는 배열 room_number가 매개변수로 주어질 때, 각 고객에게 배정되는 방 번호를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요.

[제한사항]
k는 1 이상 1012 이하인 자연수입니다.
room_number 배열의 크기는 1 이상 200,000 이하입니다.
room_number 배열 각 원소들의 값은 1 이상 k 이하인 자연수입니다.
room_number 배열은 모든 고객이 방을 배정받을 수 있는 경우만 입력으로 주어집니다.
예를 들어, k = 5, room_number = [5, 5] 와 같은 경우는 방을 배정받지 못하는 고객이 발생하므로 이런 경우는 입력으로 주어지지 않습니다.
[입출력 예]
k	room_number	result
10	[1,3,4,1,3,1]	[1,3,4,2,5,6]
입출력 예에 대한 설명
입출력 예 #1

문제의 예시와 같습니다.

첫 번째 ~ 세 번째 고객까지는 원하는 방이 비어 있으므로 즉시 배정받을 수 있습니다. 네 번째 고객의 경우 1번 방을 배정받기를 원했는데, 1번 방은 빈 방이 아니므로, 1번 보다 번호가 크고 비어 있는 방 중에서 가장 번호가 작은 방을 배정해야 합니다. 1번 보다 번호가 크면서 비어있는 방은 [2번, 5번, 6번...] 방이며, 이중 가장 번호가 작은 방은 2번 방입니다. 따라서 네 번째 고객은 2번 방을 배정받습니다. 마찬가지로 5, 6번째 고객은 각각 5번, 6번 방을 배정받게 됩니다.

solution.py
1
def solution(k, room_number):
2
    answer = []
3
    return answer
실행 결과
실행 결과가 여기에 표시됩니다.
logo
코딩테스트 연습
2020 카카오 인턴십
동굴 탐험
[카카오 인턴] 동굴 탐험
문제 설명
[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]

kakao_cave1.png

오지 탐험가인 프로도는 탐험 도중 n개의 방으로 이루어진 지하 동굴을 탐험하게 되었습니다. 모든 방에는 0부터 n - 1 까지 번호가 붙어있고, 이 동굴에 들어갈 수 있는 유일한 입구는 0번 방과 연결되어 있습니다. 각 방들은 양방향으로 통행이 가능한 통로로 서로 연결되어 있는데, 서로 다른 두 방을 직접 연결하는 통로는 오직 하나입니다. 임의의 서로 다른 두 방 사이의 최단경로는 딱 한 가지만 있으며, 또한 임의의 두 방 사이에 이동이 불가능한 경우는 없습니다.

탐험에 앞서 이 지하 동굴의 지도를 손에 넣은 프로도는 다음과 같이 탐험 계획을 세웠습니다.

모든 방을 적어도 한 번은 방문해야 합니다.
특정 방은 방문하기 전에 반드시 먼저 방문할 방이 정해져 있습니다.
2-1. 이는 A번 방은 방문하기 전에 반드시 B번 방을 먼저 방문해야 한다는 의미입니다.
2-2. 어떤 방을 방문하기 위해 반드시 먼저 방문해야 하는 방은 없거나 또는 1개 입니다.
2-3. 서로 다른 두 개 이상의 방에 대해 먼저 방문해야 하는 방이 같은 경우는 없습니다.
2-4. 어떤 방이 먼저 방문해야 하는 방이면서 동시에 나중에 방문해야 되는 방인 경우는 없습니다.
위 계획 중 2-2, 2-3, 2-4는 순서를 지켜 방문해야 하는 두 방의 쌍이 A → B(A를 먼저 방문하고 B를 방문함) 형태로 유일함을 의미합니다. 즉, 프로도는 아래와 같은 형태로 방문순서가 잡히지 않도록 방문 계획을 세웠습니다.

A → B, A → C (방문순서 배열 order = [...,[A,B],...,[A,C],...]) 형태로 A를 방문 후에 방문해야 할 방이 B와 C로 두 개 또는 그 이상인 경우
X → A, Z → A (방문순서 배열 order = [...,[X,A],...,[Z,A],...]) 형태로 A를 방문하기 전에 방문해야 할 방이 X와 Z로 두 개 또는 그 이상인 경우
A → B → C (방문순서 배열 order = [...,[A,B],...,[B,C],...) 형태로 B처럼 A 방문 후이면서 동시에 C 방문 전인 경우
그리고 먼저 방문해야 할 방과 나중에 방문할 방을 반드시 연속해서 방문해야 할 필요는 없어 A방을 방문한 후 다른 방을 방문한 후 B방을 방문해도 좋습니다.

방 개수 n, 동굴의 각 통로들이 연결하는 두 방의 번호가 담긴 2차원 배열 path, 프로도가 정한 방문 순서가 담긴 2차원 배열 order가 매개변수로 주어질 때, 프로도가 규칙에 맞게 모든 방을 탐험할 수 있을 지 return 하도록 solution 함수를 완성해주세요.

[제한사항]
n은 2 이상 200,000 이하입니다.
path 배열의 세로(행) 길이는 n - 1 입니다.
path 배열의 원소는 [방 번호 A, 방 번호 B] 형태입니다.
두 방 A, B사이를 연결하는 통로를 나타냅니다.
통로가 연결하는 두 방 번호가 순서없이 들어있음에 주의하세요.
order 배열의 세로(행) 길이는 1 이상 (n / 2) 이하입니다.
order 배열의 원소는 [방 번호 A, 방 번호 B] 형태입니다.
A번 방을 먼저 방문한 후 B번 방을 방문해야 함을 나타냅니다.
입출력 예
n	path	order	result
9	[[0,1],[0,3],[0,7],[8,1],[3,6],[1,2],[4,7],[7,5]]	[[8,5],[6,7],[4,1]]	true
9	[[8,1],[0,1],[1,2],[0,7],[4,7],[0,3],[7,5],[3,6]]	[[4,1],[5,2]]	true
9	[[0,1],[0,3],[0,7],[8,1],[3,6],[1,2],[4,7],[7,5]]	[[4,1],[8,7],[6,5]]	false
입출력 예에 대한 설명
입출력 예 #1

동굴 그림은 아래와 같습니다.

kakao_cave2.png

방문 순서를 지켜야 하는 방 번호는 다음과 같습니다.

6번 → 7번
4번 → 1번
8번 → 5번
따라서 모든 방을 방문할 수 있는 방법 중 하나는 다음과 같습니다.

0번 → 3번 → 6번 → 3번 → 0번 → 7번 → 4번 → 7번 → 0번 → 1번 → 8번 → 1번 → 2번 → 1번 → 0번 → 7번 → 5번
입출력 예 #2

kakao_cave3.png

다음 순서로 각 방을 방문하면 됩니다.

0번 → 7번 → 4번 → 7번 → 5번 → 7번 → 0번 → 3번 → 6번 → 3번 → 0번 → 1번 → 8번 → 1번 → 2번
입출력 예 #3

kakao_cave4.png

규칙에 맞게 모든 방을 방문할 수 있는 방법이 없습니다.

solution.py
1
def solution(n, path, order):
2
    answer = True
3
    return answer
실행 결과
실행 결과가 여기에 표시됩니다.
logo
코딩테스트 연습
월간 코드 챌린지 시즌1
짝수 행 세기
짝수 행 세기
문제 설명
모든 수가 0 또는 1로 이루어진 2차원 배열 a가 주어집니다. 다음 조건을 모두 만족하는 2차원 배열 b의 경우의 수를 (107 + 19)로 나눈 나머지를 return 하도록 solution 함수를 완성해주세요.

b의 모든 원소는 0 아니면 1입니다.
a의 행/열의 개수와 b의 행/열의 개수가 같습니다. (= a와 b의 크기가 같습니다.)
i = 1, 2, ..., (a의 열의 개수)에 대해서 a의 i번째 열과 b의 i번째 열에 들어 있는 1의 개수가 같습니다.
b의 각 행에 들어 있는 1의 개수가 짝수입니다. (0도 짝수입니다.)
제한 사항
a의 행의 개수는 1 이상 300 이하입니다.
a의 각 행의 길이는 1 이상 300 이하로 모두 동일합니다.
입출력 예
a	result
[[0,1,0],[1,1,1],[1,1,0],[0,1,1]]	6
[[1,0,0],[1,0,0]]	0
[[1,0,0,1,1],[0,0,0,0,0],[1,1,0,0,0],[0,0,0,0,1]]	72
입출력 예 설명
입출력 예 #1

주어진 a는 다음 표와 같은 4행 3열의 배열입니다.
a	1열	2열	3열
1행	0	1	0
2행	1	1	1
3행	1	1	0
4행	0	1	1
주어진 조건을 만족하는 2차원 배열 b는 다음과 같이 총 6개입니다.
b	1열	2열	3열
1행	1	1	0
2행	1	1	0
3행	0	1	1
4행	0	1	1
b	1열	2열	3열
1행	1	1	0
2행	0	1	1
3행	1	1	0
4행	0	1	1
b	1열	2열	3열
1행	1	1	0
2행	0	1	1
3행	0	1	1
4행	1	1	0
b	1열	2열	3열
1행	0	1	1
2행	1	1	0
3행	1	1	0
4행	0	1	1
b	1열	2열	3열
1행	0	1	1
2행	1	1	0
3행	0	1	1
4행	1	1	0
b	1열	2열	3열
1행	0	1	1
2행	0	1	1
3행	1	1	0
4행	1	1	0
입출력 예 #2

주어진 a는 다음 표와 같은 2행 3열의 배열입니다.
a	1열	2열	3열
1행	1	0	0
2행	1	0	0
주어진 조건을 만족하는 2차원 배열 b가 없으므로, 0을 return 해야 합니다.
입출력 예 #3

주어진 a는 다음 표와 같은 4행 5열의 배열입니다.
a	1열	2열	3열	4열	5열
1행	1	0	0	1	1
2행	0	0	0	0	0
3행	1	1	0	0	0
4행	0	0	0	0	1
주어진 조건을 만족하는 2차원 배열 b는 72개이므로, 72를 return 해야 합니다.
solution.py
1
def solution(a):
2
    answer = -1
3
    return answer
실행 결과
실행 결과가 여기에 표시됩니다.
logo
코딩테스트 연습
월간 코드 챌린지 시즌1
트리 트리오 중간값
트리 트리오 중간값
문제 설명
n개의 점으로 이루어진 트리가 있습니다. 이때, 트리 상에서 다음과 같은 것들을 정의합니다.

어떤 두 점 사이의 거리는, 두 점을 잇는 경로 상 간선의 개수로 정의합니다.
임의의 3개의 점 a, b, c에 대한 함수 f(a, b, c)의 값을 a와 b 사이의 거리, b와 c 사이의 거리, c와 a 사이의 거리, 3개 값의 중간값으로 정의합니다.
트리의 정점의 개수 n과 트리의 간선을 나타내는 2차원 정수 배열 edges가 매개변수로 주어집니다. 주어진 트리에서 임의의 3개의 점을 뽑아 만들 수 있는 모든 f값 중에서, 제일 큰 값을 구해 return 하도록 solution 함수를 완성해주세요.

제한 사항
n은 3 이상 250,000 이하입니다.
edges의 행의 개수는 n-1 입니다.
edges의 각 행은 [v1, v2] 2개의 정수로 이루어져 있으며, 이는 v1번 정점과 v2번 정점 사이에 간선이 있음을 의미합니다.
v1, v2는 각각 1 이상 n 이하입니다.
v1, v2는 다른 수입니다.
입력으로 주어지는 그래프는 항상 트리입니다.
입출력 예
n	edges	result
4	[[1,2],[2,3],[3,4]]	2
5	[[1,5],[2,5],[3,5],[4,5]]	2
입출력 예 설명
입출력 예 #1

다음 그림은 입력으로 주어진 트리를 나타낸 것입니다.
ex1.png

다음 표는 주어진 트리에서 나올 수 있는 모든 f값의 경우를 나열한 것입니다. (단, a, b, c의 순서만 다른 경우는 f값이 동일하기 때문에 표에서 제외)
a	b	c	a ~ b 거리	b ~ c 거리	c ~ a 거리	f(a, b, c)
1	2	3	1	1	2	1
1	2	4	1	2	3	2
1	3	4	2	1	3	2
2	3	4	1	1	2	1
따라서, 2를 return 해야 합니다.
입출력 예 #2

다음 그림은 입력으로 주어진 트리를 나타낸 것입니다.
ex2.png

f값에 사용될 3개의 점으로 (1, 2, 3), (2, 3, 4) 등을 고를 때 가장 큰 값인 2를 얻을 수 있으므로, 2를 return 해야 합니다.
solution.py
1
def solution(n, edges):
2
    answer = 0
3
    return answer
실행 결과
실행 결과가 여기에 표시됩니다.
logo
코딩테스트 연습
월간 코드 챌린지 시즌1
문자열의 아름다움
문자열의 아름다움
문제 설명
어떤 문자열 x의 "아름다움"을 다음과 같이 정의합니다.

만약 x의 모든 글자가 전부 같다면, 0입니다.
그렇지 않다면, 서로 다른 글자가 위치해 있는 두 인덱스 i, j를 골랐을 때의 j-i 값들 중 최대값입니다.
예를 들어, 문자열 "abbca"의 아름다움은 3입니다. 인덱스 1(b)과 4(a)를 고르거나, 또는 0(a)과 3(c)를 고를 때 최대값이기 때문입니다.

영어 소문자로 이루어진 문자열 s가 매개변수로 주어집니다. s의 모든 부분문자열의 아름다움의 합을 return 하도록 solution 함수를 완성해주세요.

제한 사항
s의 길이는 1 이상 300,000 이하입니다.
입출력 예
s	result
"baby"	9
"oo"	0
입출력 예 설명
입출력 예 #1

다음 표는 "baby"의 각 부분문자열과 그 아름다움을 나타낸 것입니다.
인덱스 범위	부분문자열	아름다움
0 ~ 0	"b"	0
0 ~ 1	"ba"	1 ("b", "a" 선택)
0 ~ 2	"bab"	1 (앞 "b", "a" 선택 또는 "a", 뒤 "b" 선택)
0 ~ 3	"baby"	3 (앞 "b", "y" 선택)
1 ~ 1	"a"	0
1 ~ 2	"ab"	1 ("a", "b" 선택)
1 ~ 3	"aby"	2 ("a", "y" 선택)
2 ~ 2	"b"	0
2 ~ 3	"by"	1 ("b", "y" 선택)
3 ~ 3	"y"	0
따라서, 각 부분문자열의 아름다움을 모두 더한 9를 return 해야 합니다.
입출력 예 #2

"oo"는 모든 글자가 동일하므로, "oo"의 임의의 부분문자열도 모두 동일한 글자를 가지고 있습니다.
따라서, "oo"의 임의의 부분문자열의 아름다움은 전부 0이므로, 0을 return 해야 합니다.
solution.py
1
def solution(s):
2
    answer = -1
3
    return answer
실행 결과
실행 결과가 여기에 표시됩니다.
logo
코딩테스트 연습
월간 코드 챌린지 시즌1
가짜 해밀토니안
가짜 해밀토니안
문제 설명
다음 조건을 만족하는 그래프 상의 경로(Path)를 가짜 해밀토니안 경로라고 정의합니다.

경로가 그래프 상의 모든 점을 최소 1번, 최대 2번 방문해야 합니다.
그래프의 형태에 따라, 해당 그래프가 가짜 해밀토니안 경로를 가질 수도 있고, 가지지 않을 수도 있습니다. 본 문제에서 주어지는 그래프는 항상 트리 형태이며, 다음은 트리에서 가짜 해밀토니안 경로를 나타내는 예시입니다.

expand1.png

이 트리는 가짜 해밀토니안 경로를 가지는 트리입니다. 그림의 경로가 트리 상의 모든 점을 최소 1번, 최대 2번 방문하는 가짜 해밀토니안 경로 중 하나입니다.
expand2.png

이 트리는 가짜 해밀토니안 경로를 가지지 않는 트리입니다.
트리 정보를 담고 있는 2차원 정수 배열 t가 매개변수로 주어집니다. 이 트리의 모든 부분 트리(Subtree) 중에서, 가짜 해밀토니안 경로를 갖고 있으면서 동시에 점의 개수가 제일 많은 트리의 크기를 찾아 그 트리의 점의 개수를 return 하도록 solution 함수를 완성해주세요.

이때, 점의 개수가 3 이상(제한사항을 참고해주세요)인 임의의 트리는 항상 가짜 해밀토니안 경로를 가지는 부분 트리를 가지므로, 이 문제에서 답은 항상 존재합니다.

제한사항
t의 행의 개수는 2 이상 200,000 미만입니다.
트리의 점(Vertex)의 개수는 (t의 행의 개수 + 1) 입니다. 즉, 트리의 점의 개수는 3 이상 200,000 이하입니다.
각 행은 [v1, v2] 2개의 정수로 이루어져 있습니다.
이는 v1번 점과 v2번 점이 서로 연결되어 있다는 것을 의미합니다.
v1, v2는 각각 0 이상 (t의 행의 개수) 이하입니다.
v1과 v2는 서로 다른 수입니다.
t는 항상 트리 형태로만 주어집니다.
입출력 예
t	result
[[5,1],[2,5],[3,5],[3,6],[2,4],[4,0]]	7
[[2,5],[2,0],[3,2],[4,2],[2,1]]	4
입출력 예 #1

주어진 트리를 그림으로 나타내면 다음과 같습니다. ex1.png
이 트리는 그 자체로 가짜 해밀토니안 경로를 가지므로, 트리의 점의 개수인 7을 return 해야 합니다.
입출력 예 #2

주어진 트리에서, 가짜 해밀토니안 경로를 가지면서 점의 개수가 가장 많은 부분 트리 중 하나를 그림으로 나타내면 다음과 같습니다. ex2.png
(0,1,2,3) 외에도 (0,2,4,5), (1,2,3,4) 등 가짜 해밀토니안 경로를 가지면서 점의 개수가 4개인 다른 부분 트리가 존재하지만, 동일한 조건에서 그보다 더 많은 점의 개수를 가지는 트리는 없습니다.
따라서 4를 return 해야 합니다.
solution.py
1
def solution(t):
2
    answer = 0
3
    return answer
실행 결과
실행 결과가 여기에 표시됩니다.
logo
코딩테스트 연습
2021 KAKAO BLIND RECRUITMENT
매출 하락 최소화
매출 하락 최소화
문제 설명
유통전문회사 카카오상사의 오너인 제이지는 새로운 사업 아이템을 구상하기 위해 전문경영인(CEO)인 프로도에게 회사의 경영을 부탁하였습니다.
"카카오상사"는 직원들을 여러 개의 팀 단위로 조직을 구성하고 있으며 아래 그림은 CEO를 포함하여 10명의 직원과 4개의 팀으로 구성되어 있는 회사 조직도를 보여주고 있습니다.
2021_kakao_sales_01.png
그림의 조직도는 다음과 같이 설명할 수 있습니다.

그림의 각 원들은 각각의 직원 1명을 표시하고 있으며, CEO를 포함하여 총 10명의 직원을 표시하고 있습니다.
원 안에 적힌 두 개의 숫자는 직원의 정보를 담고 있습니다. 왼쪽 숫자는 직원번호이며 직원을 식별할 수 있도록 1번부터 순서대로 발급되는 일련번호이며, 오른쪽 숫자는 해당 직원의 하루평균 매출액을 나타냅니다. 위 그림에서 1번 직원은 14원을, 9번 직원은 28원의 하루평균 매출액을 기록하고 있습니다.

CEO를 포함하여 모든 직원은 팀장 또는 팀원이라는 직위를 가지고 있으며 그림에서는 팀장과 팀원의 관계를 화살표로 표시하고 있습니다. 화살표가 시작되는 쪽의 직원은 팀장, 화살표를 받는 쪽의 직원은 팀원을 의미합니다.
3-1. 직원번호 1번은 회사의 CEO로 고정되어 있으며, CEO는 항상 팀장이고 팀원일 수 없어 화살표를 받는 쪽이 될 수 없습니다.
3-2. 반면에 CEO를 제외한 나머지 모든 직원들은 다른 누군가로부터 정확히 1개의 화살표를 받게 됩니다.
3-3. 한 직원은 최대 2개의 팀에 소속될 수 있습니다. 만약 어떤 직원이 두 개의 팀에 소속되어 있다면, 반드시 하나의 팀에서는 팀장, 나머지 팀에서는 팀원이어야 합니다. 팀장을 겸임하거나, 두 개의 팀에서 팀원이 될 수는 없습니다. 예를들어 10번 직원은 D팀의 팀장이면서 동시에 5번 직원이 팀장으로 있는 C팀에 속한 팀원입니다.
3-4. 5번, 9번, 10번 직원은 받는 쪽의 화살표와 시작하는 화살표가 모두 있으므로 팀장인 동시에 팀원입니다.
3-5. 2번, 3번, 4번, 6번, 7번, 8번 직원은 시작하는 화살표가 없고 받는 쪽의 화살표만 있으므로 팀장이 아니며 오직 팀원입니다.
3-6. 1번 직원인 CEO는 받는 쪽의 화살표가 없고 시작하는 화살표만 있으며 항상 팀원이 아닌 팀장입니다.
3-7. 그림의 조직도에는 A, B, C, D 총 4개의 팀이 존재하며, 각각 1번, 9번, 5번, 10번 직원이 팀장 직위를 담당하게 됩니다.

"제이지"는 자신이 구상한 새로운 사업 아이템에 대해 직원들에게 설명하고자 하루 일정으로 워크숍을 계획하고 있습니다. 단, 모든 직원을 참석시킬 수 없어 아래와 같은 기준으로 워크숍에 참석할 직원들을 선발하려고 합니다.

워크숍에서 교육받은 내용은 전 직원들에게 공유되어야 하므로 모든 팀은 최소 1명 이상의 직원을 워크숍에 참석시켜야 합니다.
워크숍 기간 동안, 회사의 매출 손실을 최소화하는 것이 중요하므로 워크숍에 참석하는 직원들의 하루평균 매출액의 합이 최소가 되어야 합니다.
위 그림의 조직도에서 회색으로 색칠된 1번, 7번, 10번 직원을 워크숍에 참석시키면 모든 팀에서 최소 한 명 이상의 직원을 참석시킨 것이 되며, 해당 직원들의 하루평균 매출액의 합은 44(14+13+17)원 입니다. 10번 직원은 C팀과 D팀 모두에 속해 있으므로, 두 팀에서 모두 참석한 것으로 인정됩니다.

[문제]
직원들의 하루평균 매출액 값을 담은 배열 sales, 직원들의 팀장-팀원의 관계를 나타내는 2차원 배열 links가 매개변수로 주어집니다. 이때, 모든 팀에서 최소 한 명 이상 워크숍에 참석하면서, 참석하는 직원들의 하루평균 매출액의 합을 최소로 하려고 합니다. 그렇게 최소화된 매출액의 합을 구해서 return 하도록 solution 함수를 완성해 주세요.

[제한사항]
sales 배열의 크기는 2 이상 300,000 이하입니다. sales 배열의 크기는 CEO를 포함한 전체 직원 수와 같습니다.
sales 배열은 각 직원들의 하루평균 매출액을 담고 있으며, 1번 직원부터 직원번호 순서대로 주어집니다.
sales 배열의 각 원소의 값은 0 이상 10,000 이하인 정수입니다.
links 배열의 크기는 sales 배열의 크기 - 1 입니다. 즉, 전체 직원 수보다 1이 작습니다.
links 배열의 각 원소는 [a, b] 형식입니다.
a는 팀장의 직원번호, b는 a팀장이 관리하는 팀원의 직원번호이며, a와 b는 서로 다른 자연수입니다.
1 ≤ a ≤ sales 배열의 크기 입니다.
2 ≤ b ≤ sales 배열의 크기 입니다.
직원번호 1은 CEO로 정해져 있고 CEO는 항상 팀장으므로 b ≠ 1 입니다.
links 배열로 만들어지는 조직도는 하나의 트리 구조 형태입니다.
정답으로 return 되는 값은 231 - 1 이하인 자연수임이 보장됩니다.
[입출력 예]
sales	links	result
[14, 17, 15, 18, 19, 14, 13, 16, 28, 17]	[[10, 8], [1, 9], [9, 7], [5, 4], [1, 5], [5, 10], [10, 6], [1, 3], [10, 2]]	44
[5, 6, 5, 3, 4]	[[2,3], [1,4], [2,5], [1,2]]	6
[5, 6, 5, 1, 4]	[[2,3], [1,4], [2,5], [1,2]]	5
[10, 10, 1, 1]	[[3,2], [4,3], [1,4]]	2
입출력 예에 대한 설명
입출력 예 #1
문제 예시와 같습니다.

입출력 예 #2
직원번호가 2인 직원 한 명을 워크숍에 참석시키는 것이 최선이며, 2번 직원의 하루평균 매출액은 6원입니다. 따라서 6을 return 해주어야 합니다.
2021_kakao_sales_02.png

입출력 예 #3
직원번호가 4, 5인 직원 두 명을 워크숍에 참석시키는 것이 최선이며, 4번, 5번 직원의 하루평균 매출액의 합은 5(1+4)원 입니다. 따라서 5를 return 해주어야 합니다.
2021_kakao_sales_03.png

입출력 예 #4
직원번호가 3, 4인 직원 두 명을 워크숍에 참석시키는 것이 최선이며, 3번, 4번 직원의 하루평균 매출액의 합은 2(1+1)원 입니다. 따라서 2를 return 해주어야 합니다.
2021_kakao_sales_04.png

solution.py
1
def solution(sales, links):
2
    answer = 0
3
    return answer
실행 결과
실행 결과가 여기에 표시됩니다.
logo
코딩테스트 연습
월간 코드 챌린지 시즌2
RPG와 쿼리
RPG와 쿼리
문제 설명
당신은 어떤 RPG 게임의 주인공입니다. 게임에는 n개의 도시(0번, 1번, ..., n-1번)와 m개의 도시 간 도로, 그리고 상수값 z가 있습니다. 각 도로는 일방통행이며, 도로마다 다른 가중치값 w (이 w는 z보다 항상 작습니다)를 가지고 있습니다.

당신은 게임 도중 매 턴당 다음 행동 중 하나를 취할 수 있습니다.

현재 있는 도시에서 연결된 도로를 따라 다른 도시로 이동합니다. 해당 도로의 가중치값을 w라고 할 때, w원을 얻습니다.
현재 있는 도시에서 움직이지 않고 z원을 얻습니다.
원하는 아무 도시로 순간 이동합니다. 이때 얻는 돈은 없습니다.
여기서 주의해야 할 점은, 같은 도로를 몇 번을 사용하든 그 도로를 사용할 때마다 얻는 금액은 동일하다는 것입니다.

이때, 당신에게 q개의 쿼리가 주어집니다. 각 쿼리는 단일 숫자 c로 이루어져 있으며, 당신은 이 게임을 0번 도시에서 0원을 가진 상태에서 시작했을 때, 정확히 c원을 얻는 것이 가능한지, 가능하다면 최소 몇 턴만에 c원을 얻을 수 있는지를 판별해야 합니다.

도시의 숫자 n, 게임의 상수값 z, 도시 간 도로의 정보 roads, 그리고 쿼리들로 이루어진 배열 queries가 매개변수로 주어집니다. 주어진 정보들을 활용하여 각 쿼리의 답(불가능한 경우 -1)을 배열에 담아 return 하도록 solution 함수를 완성해주세요.

제한사항
n은 2 이상 3,000 이하입니다.
z는 2 이상 50 이하입니다.
roads의 길이는 1 이상 3,000 이하입니다.
roads의 각 행은 [u, v, w] 3개의 정수로 이루어져 있으며, 이는 u번 도시부터 v번 도시까지 도로가 연결되어 있고, 해당 도로를 따라 이동했을 때 w원을 얻을 수 있음을 의미합니다.
0 ≤ u, v < n 입니다.
1 ≤ w < z 입니다.
u와 v는 서로 다른 수입니다.
u번 도시에서 v번 도시로 가는 도로는 최대 하나뿐입니다.
queries의 길이는 1 이상 100,000 이하입니다.
queries의 모든 숫자는 0 이상 1018 이하입니다.
입출력 예
n	z	roads	queries	result
5	5	[[1,2,3],[0,3,2]]	[0,1,2,3,4,5,6]	[0,-1,1,2,3,1,4]
입출력 예 설명
입출력 예 #1

게임에 도시가 5개, z = 5, 그리고 도로가 2개 있습니다.
다음 그림은 각 쿼리 별로 가장 빠르게 해당 금액을 정확히 획득하는 법을 도식화한 것입니다. rpg_millionaire_example.png
0원은 시작할 때부터 가지고 있으므로, 답은 0입니다.
1원을 가지는 것은 불가능하므로, 답은 -1입니다.
2원을 가지기 위해서는 0번 도시에서 3번 도시로 도로를 타고 이동하면 가장 빠르므로, 답은 1입니다.
3원을 가지기 위해서는 0번 도시에서 1번 도시로 순간 이동한 뒤, 2번 도시로 도로를 타고 이동하면 가장 빠르므로, 답은 2입니다.
4원을 가지기 위해서는 0번 도시에서 3번 도시로 도로를 타고 이동하고, 다시 0번 도시로 순간 이동해서 똑같은 도로를 다시 사용하면 가장 빠르므로, 답은 3입니다.
5원을 가지기 위해서는 0번 도시에서 가만히 있으면(2번째 행동) 가장 빠르므로, 답은 1입니다.
6원을 가지기 위해서는 1번 도시로 순간이동하고, 2번 도시로 도로를 타고 이동하고, 다시 1번 도시로 순간 이동해서 똑같은 도로를 다시 사용하면 가장 빠르므로, 답은 4입니다.
따라서, [0,-1,1,2,3,1,4] 를 return 해야 합니다.
solution.py
1
def solution(n, z, roads, queries):
2
    answer = []
3
    return answer
실행 결과
실행 결과가 여기에 표시됩니다.
logo
코딩테스트 연습
월간 코드 챌린지 시즌2
중력 작용
중력 작용
문제 설명
1부터 n까지 번호가 하나씩 붙은 n개의 노드를 갖는 트리가 주어집니다. 각 노드에는 값이 하나씩 들어 있으며, 이 트리의 루트 노드는 1번 노드입니다. 당신은 이 트리에 대해 다음과 같은 쿼리 두 종류를 처리하면 됩니다.

1번 쿼리: 정수 u가 주어집니다. u번 노드의 서브 트리의 모든 노드의 값의 합을 구해야 합니다.
2번 쿼리: 정수 u, w가 주어집니다. u번 노드의 값을 삭제한 뒤, u번 노드의 부모 노드의 값을 u번 노드로 복사합니다., u번 노드의 부모 노드에 대해 같은 작업을 반복하며 루트노드까지 거슬러 올라갑니다. 마지막으로 루트 노드의 값을 w로 바꿉니다.
트리의 노드 초기값이 담긴 정수 배열 values, 트리의 연결 상태가 담긴 2차원 정수 배열 edges, 쿼리들이 담긴 2차원 정수 배열 queries가 주어집니다. 쿼리들을 순서대로 처리할 때, 각 1번 쿼리에 대한 답을 수행 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요.

제한사항
1 ≤ values의 길이 ≤ 100,000
values의 길이는 트리의 노드 개수를 의미합니다.
values[i]는 i+1번 노드의 초기 값을 의미합니다.
edges의 길이 = values의 길이 - 1
edges의 각 행은 [v1, v2] 2개의 정수로 이루어져 있으며, 이는 v1번 노드와 v2번 노드가 연결되어 있음을 의미합니다.
주어진 그래프는 항상 1번 노드가 루트인 트리 형태입니다.
1 ≤ queries의 길이 ≤ 100,000
queries의 각 행은 단일 쿼리를 의미하며, [u, w] 2개의 정수로 이루어져 있습니다.
1 ≤ u ≤ values의 길이
-1 ≤ w ≤ 109
w가 -1일 경우, 이 쿼리는 1번 쿼리이며, 그렇지 않을 경우 이 쿼리는 2번 쿼리입니다.
입출력 예
values	edges	queries	result
[1,10,100,1000,10000]	[[1,2],[1,3],[2,4],[2,5]]	[[1,-1],[2,-1],[3,-1],[4,-1],[5,-1],[4,1000],[1,-1],[2,-1],[3,-1],[4,-1],[5,-1],[2,1],[1,-1],[2,-1],[3,-1],[4,-1],[5,-1]]	[11111,11010,100,1000,10000,11111,10011,100,10,10000,11111,11010,100,10,10000]
입출력 예 설명
입출력 예 #1

주어진 예시는 1번 쿼리 15개와 2번 쿼리 2개로 이루어져 있습니다.
다음 그림은 두 2번 쿼리에 의해 트리의 노드 값들이 바뀌는 과정을 나타낸 것입니다.
gravity_on_tree_example.png

solution.py
1
def solution(values, edges, queries):
2
    answer = []
3
    return answer
실행 결과
실행 결과가 여기에 표시됩니다.
logo
코딩테스트 연습
2021 카카오 채용연계형 인턴십
미로 탈출
미로 탈출
문제 설명
신규 게임 ‘카카오 미로 탈출’이 출시되어, 라이언이 베타테스터로 참가했습니다.

Maze.png

위 예시 그림은 카카오 미로 탈출의 초기 상태를 나타냅니다. 1번부터 3번까지 번호가 붙어있는 3개의 방이 있고, 방과 방 사이를 연결하는 길에는 이동하는데 걸리는 시간이 표시되어 있습니다. 길은 화살표가 가리키는 방향으로만 이동할 수 있습니다. 미로에는 함정이 존재하며, 함정으로 이동하면, 이동한 함정과 연결된 모든 화살표의 방향이 바뀝니다.
출발지점인 1번 방에서 탈출이 가능한 3번 방까지 이동해야 합니다. 탈출하는데 걸리는 최소 시간을 구하려고 합니다.

그림의 원은 방을 나타내며 원 안의 숫자는 방 번호를 나타냅니다.
방이 n개일 때, 방 번호는 1부터 n까지 사용됩니다.
화살표에 표시된 숫자는 방과 방 사이를 이동할 때 걸리는 시간을 나타냅니다.
화살표가 가리키고 있는 방향으로만 이동이 가능합니다. 즉, 위 그림에서 2번 방에서 1번 방으로는 이동할 수 없습니다.
그림에 표시된 빨간색 방인 2번 방은 함정입니다.
함정 방으로 이동하는 순간, 이동한 함정 방과 연결되어있는 모든 길의 방향이 반대가 됩니다.
위 그림 1번 방에서 2번 방으로 이동하는 순간 1에서 2로 이동할 수 있던 길은 2에서 1로 이동할 수 있는 길로 바뀌고, 3에서 2로 이동할 수 있던 길은 2에서 3으로 이동할 수 있는 길로 바뀝니다.
똑같은 함정 방을 두 번째 방문하게 되면 원래 방향의 길로 돌아옵니다. 즉, 여러 번 방문하여 계속 길의 방향을 반대로 뒤집을 수 있습니다.
미로를 탈출하는데 필요한 최단 시간은 다음과 같습니다.
1→2: 2번 방으로 이동합니다. 이동 시간은 2입니다.
함정 발동: 2번 방과 연결된 모든 길의 방향이 반대가 됩니다.
2→3: 3번 방으로 이동합니다. 이동 시간은 3입니다.
탈출에 성공했습니다. 총 이동시간은 5입니다.
방의 개수를 나타내는 정수 n, 출발 방의 번호 start, 도착 방의 번호 end, 통로와 이동시간을 나타내는 2차원 정수 배열 roads, 함정 방의 번호를 담은 정수 배열 traps이 매개변수로 주어질 때, 미로를 탈출하는데 필요한 최단 시간을 return 하도록 solution 함수를 완성해주세요.

제한사항
2 ≤ n ≤ 1,000
1 ≤ start ≤ n
1 ≤ end ≤ n
1 ≤ roads의 행 길이 ≤ 3,000
roads의 행은 [P, Q, S]로 이루어져 있습니다.
P에서 Q로 갈 수 있는 길이 있으며, 길을 따라 이동하는데 S만큼 시간이 걸립니다.
1 ≤ P ≤ n
1 ≤ Q ≤ n
P ≠ Q
1 ≤ S ≤ 3,000
서로 다른 두 방 사이에 직접 연결된 길이 여러 개 존재할 수도 있습니다.
0 ≤ traps의 길이 ≤ 10
1 ≤ traps의 원소 ≤ n
시작 방과 도착 방은 함정이 아닙니다.
항상 미로를 탈출할 수 있는 경우만 주어집니다.
입출력 예
n	start	end	roads	traps	result
3	1	3	[[1, 2, 2], [3, 2, 3]]	[2]	5
4	1	4	[[1, 2, 1], [3, 2, 1], [2, 4, 1]]	[2, 3]	4
입출력 예 설명
입출력 예 #1

문제 예시와 같습니다.

입출력 예 #2

MazeEx2.png

1 → 2 → 3 → 2 → 4 순서로 이동하면 됩니다. 총 이동시간은 4입니다.

제한시간 안내
정확성 테스트 : 10초
solution.py
1
def solution(n, start, end, roads, traps):
2
    answer = 0
3
    return answer
실행 결과
실행 결과가 여기에 표시됩니다.
logo
코딩테스트 연습
2021 카카오 채용연계형 인턴십
시험장 나누기
시험장 나누기
문제 설명
[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]

카카오 인턴을 선발하는 코딩 테스트 시험장이 하나의 이진 트리1 형태로 연결되어 있습니다. 아래 그림은 12개의 시험장이 연결된 예시입니다.

img1.png

하나의 노드는 하나의 시험장을 나타냅니다.
검은 바탕의 흰 숫자는 해당 시험장의 고유 번호(ID)를 나타냅니다.

2-1. 시험장이 n개 있다면, 시험장의 고유 번호는 0부터 n-1까지 부여됩니다.

노드 안의 빨간 숫자는, 해당 시험장의 응시자 수를 나타냅니다.

3-1. 위의 그림에서, 9번 시험장에는 10명, 4번 시험장에는 8명, 6번 시험장에는 20명의 응시자가 시험을 볼 예정입니다.

노드 사이의 간선은 해당 시험장이 연결되어 있음을 의미합니다.

4-1. 위의 그림에서, 9번 시험장은 7번 시험장과, 7번 시험장은 6번 시험장과 연결되어 있습니다.

코딩 테스트를 총괄하는 무지는 안정적인 시험을 위해, 시험장에서 오는 트래픽을 k개의 그룹으로 나누어 각 그룹별 서버로 분산시키기로 하였습니다. 시험장 사이를 연결한 간선들 중 k-1개를 끊어서 시험장을 k 개의 그룹으로 나눌 계획입니다. 이때, 그룹별 최대 트래픽을 최소화하기 위하여 가장 큰 그룹의 인원을 최소화시켜야 합니다.

img2.png

위의 그림에서 7번과 6번 시험장을 잇는 간선을 끊고, 9번과 7번 시험장을 잇는 간선을 끊는다면, 전체 시험장은 3개의 그룹으로 나누어집니다.

주황색 노드로 표시된 A그룹의 인원은 35명(10+8+5+6+1+1+4)
보라색 노드로 표시된 B그룹의 인원은 37명(7+30)
녹색 노드로 표시된 C그룹의 인원은 40명(20+8+12)
즉, 인원이 가장 많은 그룹은 40명입니다. 다른 어떤 방법으로 시험장을 3개의 그룹으로 나눈다고 해도, 인원이 가장 많은 그룹의 인원이 40명 미만이 되도록 나눌 수는 없습니다.

나눌 그룹의 수를 나타내는 정수 k, 각 시험장의 응시자 수를 나타내는 1차원 정수 배열 num, 시험장의 연결 상태를 나타내는 2차원 정수 배열 links가 매개변수로 주어집니다. 인원이 가장 많은 그룹의 인원이 최소화되도록 k개의 그룹으로 나누었을 때, 최소화된 최대 그룹의 인원을 return 하도록 solution 함수를 완성해주세요.

제한사항
1 ≤ k ≤ 10,000
k ≤ num의 길이 ≤ 10,000
num[i]에는 i번 시험장의 응시자 수가 담겨있습니다.
1 ≤ num의 원소 ≤ 10,000
links의 길이 = num의 길이
links의 i번째 행은 i번 노드(시험장)의 [왼쪽 자식 노드 번호, 오른쪽 자식 노드 번호]입니다.
해당 위치에 자식 노드가 없는 경우 -1이 담겨있습니다.
잘못된 노드 번호나, 하나의 이진 트리 구조가 아닌 입력은 주어지지 않습니다.
정확성 테스트 케이스 제한 사항
1 ≤ k ≤ 20
k ≤ num의 길이 ≤ 20
효율성 테스트 케이스 제한 사항
주어진 조건 외 추가 제한사항 없습니다.
입출력 예
k	num	links	result
3	[12, 30, 1, 8, 8, 6, 20, 7, 5, 10, 4, 1]	[[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 5], [2, 10], [3, 0], [6, 1], [11, -1], [7, 4], [-1, -1], [-1, -1]]	40
1	[6, 9, 7, 5]	[[-1, -1], [-1, -1], [-1, 0], [2, 1]]	27
2	[6, 9, 7, 5]	[[-1, -1], [-1, -1], [-1, 0], [2, 1]]	14
4	[6, 9, 7, 5]	[[-1, -1], [-1, -1], [-1, 0], [2, 1]]	9
입출력 예 설명
입출력 예 #1

문제 예시와 같습니다.

입출력 예 #2

img3.png

나눌 그룹의 수가 1개 이므로, 주어진 트리를 나눌 수 없습니다.
보라색 노드로 표시된 유일한 그룹의 인원은 27명입니다.
입출력 예 #3

img4.png

나눌 그룹의 수가 2개 이므로, 그림과 같이 1개의 간선을 끊어서 2개의 그룹으로 나눌 수 있습니다.
보라색 노드로 표시된 그룹은 13명, 주황색 노드로 표시된 그룹은 14명입니다.
따라서, 최대 그룹의 인원은 14명입니다.
입출력 예 #4

img5.png

나늘 그룹의 수가 4개 이므로, 그림과 같이 3개의 모든 간선을 끊어서 4개의 그룹으로 나눌 수 있습니다.
최대 그룹의 인원은 9명입니다.
제한시간 안내
정확성 테스트 : 10초
효율성 테스트 : 언어별로 작성된 정답 코드의 실행 시간의 적정 배수
이진 트리 : 모든 노드들의 자식 노드가 두 개 이하인 트리 ↩

solution.py
1
def solution(k, num, links):
2
    answer = 0
3
    return answer
실행 결과
실행 결과가 여기에 표시됩니다.
logo
코딩테스트 연습
월간 코드 챌린지 시즌3
안티세포
안티 세포
문제 설명
당신에게 자연수로 이루어진 길이가 n인 배열 b가 주어집니다. 초기에는 모든 수들이 "안티 세포" 안에 들어있습니다. 일반적인 세포는 분열을 하지만, 이 안티 세포는 반대로 여러 안티 세포가 모여 합성을 합니다. 당신은 다음과 같은 과정을 통해 인접한 두 안티 세포를 합치거나 또는 그대로 두려고 합니다.

i=0로 설정하고, 빈 배열 c를 하나 만듭니다.
i가 n이라면 과정을 종료합니다.
b[i]를 포함하는 안티 세포를 X, 그리고 X 바로 왼쪽에 있는 안티 세포를 Y라고 정의합니다. 만약 Y가 존재하고 X의 모든 숫자의 합과 Y의 모든 숫자의 합이 같다면, 당신은 이 두 안티 세포를 합치거나 합치지 않는 행동 중에서 하나를 선택할 수 있습니다.
만약 X와 Y를 합친다면, 둘을 합치고, c의 맨 뒤에 i를 추가한 뒤 다시 3번 과정으로 돌아갑니다.
만약 X와 Y를 합치지 않는다면(또는 Y가 존재하지 않는다면), i를 1 증가시키고 2번 과정으로 돌아갑니다.
예를 들어, 다음은 b = [1,1,1,1]일 때 위와 같은 과정을 거치는 것을 나타낸 것입니다.

i	안티 세포	c	비고
0	(1)(1)(1)(1)	[]	초기 상태입니다.
1	(1)(1)(1)(1)	[]	i=0 일 때는 Y가 존재하지 않으므로 i를 1 증가시켰습니다.
1	(1,1)(1)(1)	[1]	b[1]을 포함하는 안티 세포(X)와 그 왼쪽의 안티 세포(Y)를 합쳤습니다. 따라서 c에 i=1이 추가됩니다.
2	(1,1)(1)(1)	[1]	b[1]을 포함하는 안티 세포(X) 왼쪽의 안티 세포 Y가 존재하지 않으므로 i를 1 증가시켰습니다.
3	(1,1)(1)(1)	[1]	X의 모든 수의 합은 1이고, Y의 모든 수의 합은 2이므로, 둘은 합칠 수 없습니다. 따라서 i을 1 증가시켰습니다.
3	(1,1)(1,1)	[1,3]	b[3]을 포함하는 안티 세포(X)와 그 왼쪽의 안티 세포(Y)를 합쳤습니다. 따라서 c에 i=3이 추가됩니다.
4	(1,1)(1,1)	[1,3]	b[3]을 포함하는 안티 세포(X)와 그 왼쪽의 안티 세포(Y)를 합칠 수 있었지만 그러지 않았습니다. 따라서 i를 1 증가시켰습니다.
이 경우 c = [1,3]이 됩니다. 물론 이는 c를 만들 수 있는 하나의 경우일 뿐이며, 당신의 선택에 따라 [], [1], [3], [1,3], [2], [1,3,3]으로 c배열을 다양하게 만들 수 있습니다. 당신이 어떤 선택을 하더라도 유한한 횟수 안에 c 배열을 만들 수 있음은 증명될 수 있습니다.

당신은 b가 주어졌을 때 만들 수 있는 서로 다른 배열 c의 개수가 몇 개인지 알고 싶습니다.

정수로 이루어진 배열 a와 s가 매개변수로 주어집니다. a는 여러 개의 b 배열을 순서대로 이어 붙인 배열이며, s는 각 b 배열의 길이가 순서대로 담긴 배열입니다. 각 b 배열에 대해 문제의 답을 109 + 7로 나눈 나머지를 구하여 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.

예를 들어, a = [1,2,3,4,5,6,7,8,9], s = [2,3,4] 라면, 다음 3가지 b 배열에 대해서 답을 구해야 합니다.

b = [1,2] (s[0] = 2 이므로, a의 첫 2개 원소가 b 배열을 이룹니다.)
b = [3,4,5] (s[1] = 3 이므로, a의 그다음 3개 원소가 b 배열을 이룹니다.)
b = [6,7,8,9] (s[2] = 4 이므로, a의 그다음 4개 원소가 b 배열을 이룹니다.)
제한사항
1 ≤ a의 길이 ≤ 200,000
1 ≤ a의 모든 수 ≤ 109
1 ≤ s의 길이 ≤ a의 길이
1 ≤ s의 모든 수 ≤ a의 길이
s의 모든 수의 합 = a의 길이
입출력 예
a	s	result
[1,1,1,1,1,1,2,5,8,2,1,1,4,8,8,8,12,6,6]	[4,3,1,5,6]	[6,3,1,5,9]
입출력 예 설명
입출력 예 #1

다음 5개의 b 배열에 대한 답을 구해야 합니다.
b	답
[1,1,1,1]	6
[1,1,2]	3
[5]	1
[8,2,1,1,4]	5
[8,8,8,12,6,6]	9
따라서, [6,3,1,5,9]를 return 해야 합니다.
solution.py
1
def solution(a, s):
2
    answer = []
3
    return answer
실행 결과
실행 결과가 여기에 표시됩니다.
logo
코딩테스트 연습
월간 코드 챌린지 시즌3
쿼리의 모음의 개수
쿼리의 모음의 개수
문제 설명
길이가 n인 배열 a가 주어집니다. 당신은 여기에 q개의 쿼리를 순차적으로 날려 n개의 0으로 이루어진 배열을 a로 만들고자 합니다.

query(l, r, x)는 다음 수도코드와 같은 역할을 합니다. (0 ≤ l ≤ r < n, 1 ≤ x ≤ 105 )

for i = l, l+1, ..., r:
    a[i] := max(a[i], x)
q개의 쿼리를 통해 a를 만드는 방법은 여러 가지가 있을 수 있습니다. 예를 들어 a = [1,2], q = 2라면 다음 4가지 방법으로 a를 만들 수 있습니다.

query(0, 0, 1), query(1, 1, 2)
query(1, 1, 2), query(0, 0, 1)
query(0, 1, 1), query(1, 1, 2)
query(1, 1, 2), query(0, 1, 1)
정수 q와 정수 배열 a가 매개변수로 주어집니다. q개의 쿼리를 통해 a를 만드는 방법의 가짓수를 998,244,353으로 나눈 나머지를 return 하도록 solution 함수를 완성해주세요.

제한사항
1 ≤ q ≤ 50
1 ≤ a의 길이 ≤ 50
1 ≤ a의 모든 원소 ≤ 105
입출력 예
q	a	result
2	[1,2]	4
3	[3]	19
5	[1,4,4]	157740
50	[1,6,5,2,4]	61953538
입출력 예 설명
입출력 예 #1

문제 예시와 같습니다.
입출력 예 #2

a를 만들기 위해 날릴 수 있는 쿼리는 오직 query(0, 0, 1), query(0, 0, 2), query(0, 0, 3) 뿐입니다. 33 = 27가지 경우의 수 중에서 query(0, 0, 3)을 사용하지 않는 8가지 경우를 걸러내면 답은 27 - 8 = 19가 됩니다. 따라서, 19를 return 해야 합니다.
입출력 예 #3

a를 만들 수 있는 경우의 수가 157,740가지 이므로, 157,740을 return 해야 합니다.
입출력 예 #4

설명 생략
solution.py
1
def solution(q, a):
2
    answer = -1
3
    return answer
실행 결과
실행 결과가 여기에 표시됩니다.